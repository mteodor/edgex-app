package main

import (
	"encoding/json"
	"fmt"
	"html"
	"net/http"
	"time"

	nats "github.com/nats-io/go-nats"
)

// Connect to a server

type AutoGenerated struct {
	ID       string      `json:"id"`
	Pushed   int         `json:"pushed"`
	Device   string      `json:"device"`
	Created  int64       `json:"created"`
	Modified int         `json:"modified"`
	Origin   int64       `json:"origin"`
	Schedule interface{} `json:"schedule"`
	Event    interface{} `json:"event"`
	Readings []struct {
		ID       string `json:"id"`
		Pushed   int    `json:"pushed"`
		Created  int64  `json:"created"`
		Origin   int64  `json:"origin"`
		Modified int    `json:"modified"`
		Device   string `json:"device"`
		Name     string `json:"name"`
		Value    string `json:"value"`
	}
}

func main() {

	// Connect to a server
	var edgexReading = AutoGenerated{}
	fmt.Printf("%s\n", nats.DefaultURL)
	nc, error := nats.Connect(nats.DefaultURL)
	if error != nil {
		fmt.Printf("Failed to connect\n")
	}
	defer closeConn(nc)
	// Simple Async Subscriber
	nc.Subscribe("out.unknown", func(m *nats.Msg) {
		fmt.Printf("Received a message: %s\n", string(m.Data))
		json.Unmarshal(m.Data, &edgexReading)
	})

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {

		// If request is GET with correct syntax

		fmt.Fprintf(w, "%q",
			html.EscapeString("working\n"))

	})
	// Create a server and run it on 8000 port
	s := &http.Server{
		Addr:           ":8000",
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}
	s.ListenAndServe()

}

func closeConn(nc *nats.Conn) {
	// Drain connection (Preferred for responders)
	// Close() not needed if this is called.
	fmt.Printf("closing down")
	if nc == nil {
		return
	}

	nc.Drain()
	nc.Close()
}
